# å›¾ä¹¦æ£€ç´¢ç»“æœç›‘æ§æ˜¾ç¤ºå®æ–½æŒ‡å—

**æ—¥æœŸ**: 2025-12-17  
**ç›®æ ‡**: æä¾›è¯¦ç»†çš„ä»£ç ä¿®æ”¹æŒ‡å—ï¼Œå®ç°å›¾ä¹¦æ£€ç´¢ç»“æœçš„ç›‘æ§æ˜¾ç¤ºåŠŸèƒ½

## 1. ç±»å‹å®šä¹‰æ‰©å±•

### 1.1 ä¿®æ”¹ `src/core/aibot/types.ts`

åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ ä»¥ä¸‹ç±»å‹å®šä¹‰ï¼š

```typescript
// å›¾ä¹¦ä¿¡æ¯ç»“æ„
export interface BookInfo {
    id: string;
    title: string;
    subtitle?: string;
    author: string;
    translator?: string;
    publisher?: string;
    publishYear?: number;
    rating?: number;
    callNumber?: string;
    pageCount?: number;
    coverUrl?: string;
    description?: string;
    authorIntro?: string;
    tableOfContents?: string;
    highlights?: string[];
    isbn?: string;
    tags?: string[];
}

// æ£€ç´¢ç»“æœæ•°æ®ç»“æ„
export interface RetrievalResultData {
    books: BookInfo[];
    totalCount: number;
    searchQuery: string;
    searchType: 'text-search' | 'multi-query';
    metadata: Record<string, unknown>;
    timestamp: string;
}

// æ‰©å±•çš„RetrievalResult
export interface EnhancedRetrievalResult<TMetadata = Record<string, unknown>> extends RetrievalResult<TMetadata> {
    structuredData?: RetrievalResultData;
}
```

## 2. åç«¯APIä¿®æ”¹

### 2.1 ä¿®æ”¹ `src/core/aibot/retrievalService.ts`

æ·»åŠ ç»“æ„åŒ–å“åº”è§£æå‡½æ•°ï¼š

```typescript
// åœ¨ç°æœ‰importåæ·»åŠ 
import type { BookInfo, RetrievalResultData, EnhancedRetrievalResult } from '@/src/core/aibot/types';

// æ·»åŠ ç»“æ„åŒ–å“åº”è§£æå‡½æ•°
async function parseRetrievalResponse(
    response: Response,
    endpoint: string,
    payload: Record<string, unknown>
): Promise<RetrievalResultData> {
    try {
        // å°è¯•è§£æJSONå“åº”
        const data = await response.clone().json();
        
        // å¦‚æœæ˜¯plain_textæ ¼å¼ï¼Œä»context_plain_textè§£æ
        if (data.context_plain_text) {
            return parsePlainTextToBooks(data.context_plain_text, payload, endpoint);
        }
        
        // å¦‚æœæ˜¯JSONæ ¼å¼ï¼Œç›´æ¥è§£æresultsæ•°ç»„
        if (data.results && Array.isArray(data.results)) {
            return parseJsonResultsToBooks(data.results, payload, endpoint);
        }
        
        // å…œåº•å¤„ç†
        return {
            books: [],
            totalCount: 0,
            searchQuery: payload.query as string || payload.markdown_text as string || '',
            searchType: endpoint.includes('text-search') ? 'text-search' : 'multi-query',
            metadata: data.metadata || {},
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        logger.error('è§£ææ£€ç´¢å“åº”å¤±è´¥', { error, endpoint });
        return {
            books: [],
            totalCount: 0,
            searchQuery: payload.query as string || payload.markdown_text as string || '',
            searchType: endpoint.includes('text-search') ? 'text-search' : 'multi-query',
            metadata: {},
            timestamp: new Date().toISOString()
        };
    }
}

// è§£æçº¯æ–‡æœ¬æ ¼å¼ä¸ºç»“æ„åŒ–æ•°æ®
function parsePlainTextToBooks(
    plainText: string,
    payload: Record<string, unknown>,
    endpoint: string
): RetrievalResultData {
    // æŒ‰è¡Œåˆ†å‰²æ–‡æœ¬
    const lines = plainText.split('\n').filter(line => line.trim());
    const books: BookInfo[] = [];
    
    lines.forEach((line, index) => {
        // å°è¯•è§£ææ ¼å¼ï¼šã€ä¹¦åã€‘äº®ç‚¹ - è¯„åˆ†åˆ†
        const match = line.match(/^ã€(.+?)ã€‘(.+?)\s*-\s*([\d.]+)åˆ†$/);
        if (match) {
            books.push({
                id: `book-${index}`,
                title: match[1].trim(),
                highlights: [match[2].trim()],
                rating: parseFloat(match[3]),
                // å…¶ä»–å­—æ®µä¸ºç©ºï¼Œå› ä¸ºçº¯æ–‡æœ¬æ ¼å¼ä¿¡æ¯æœ‰é™
            });
        } else {
            // å…¶ä»–æ ¼å¼çš„å…œåº•å¤„ç†
            books.push({
                id: `book-${index}`,
                title: line.trim(),
                description: line.trim()
            });
        }
    });
    
    return {
        books,
        totalCount: books.length,
        searchQuery: payload.query as string || payload.markdown_text as string || '',
        searchType: endpoint.includes('text-search') ? 'text-search' : 'multi-query',
        metadata: {},
        timestamp: new Date().toISOString()
    };
}

// è§£æJSONæ ¼å¼ä¸ºç»“æ„åŒ–æ•°æ®
function parseJsonResultsToBooks(
    results: any[],
    payload: Record<string, unknown>,
    endpoint: string
): RetrievalResultData {
    const books: BookInfo[] = results.map((item, index) => ({
        id: item.id || `book-${index}`,
        title: item.title || item.è±†ç“£ä¹¦å || '',
        subtitle: item.subtitle || item.è±†ç“£å‰¯æ ‡é¢˜,
        author: item.author || item.è±†ç“£ä½œè€… || '',
        translator: item.translator || item.è±†ç“£è¯‘è€…,
        publisher: item.publisher,
        publishYear: item.publishYear || item.è±†ç“£å‡ºç‰ˆå¹´ä»½,
        rating: item.rating || item.è±†ç“£è¯„åˆ†,
        callNumber: item.callNumber || item.ç´¢ä¹¦å·,
        pageCount: item.pageCount || item.è±†ç“£é¡µæ•°,
        coverUrl: item.coverUrl,
        description: item.description || item.è±†ç“£å†…å®¹ç®€ä»‹,
        authorIntro: item.authorIntro || item.è±†ç“£ä½œè€…ç®€ä»‹,
        tableOfContents: item.tableOfContents || item.è±†ç“£ç›®å½•,
        highlights: item.highlights,
        isbn: item.isbn,
        tags: item.tags
    }));
    
    return {
        books,
        totalCount: books.length,
        searchQuery: payload.query as string || payload.markdown_text as string || '',
        searchType: endpoint.includes('text-search') ? 'text-search' : 'multi-query',
        metadata: { results },
        timestamp: new Date().toISOString()
    };
}

// ä¿®æ”¹postBookApiå‡½æ•°ï¼Œè¿”å›EnhancedRetrievalResult
async function postBookApi<T>(
    path: string,
    payload: Record<string, unknown>
): Promise<EnhancedRetrievalResult<T>> {
    const endpoint = `${getBookApiBase()}${path}`;
    logger.debug('è¯·æ±‚å›¾ä¹¦æ£€ç´¢ API', { endpoint, payloadKeys: Object.keys(payload) });

    const response = await fetch(endpoint, {
        method: 'POST',
        headers: JSON_HEADERS,
        body: JSON.stringify(payload)
    });

    if (!response.ok) {
        logger.error('å›¾ä¹¦æ£€ç´¢ API è°ƒç”¨å¤±è´¥', { endpoint, status: response.status });
        throw new Error(`å›¾ä¹¦æ£€ç´¢ API è¿”å› ${response.status}`);
    }

    const contentType = response.headers.get('content-type') ?? '';
    let contextPlainText: string;
    let metadata: T = {} as T;

    if (contentType.includes('text/plain')) {
        contextPlainText = await response.text();
    } else {
        const data = await response.json();
        contextPlainText = data.context_plain_text ?? data.contextPlainText ?? '';
        metadata = (data.metadata ?? {}) as T;
    }

    if (!contextPlainText) {
        logger.error('API å“åº”ç¼ºå°‘ context_plain_text', { endpoint });
        throw new Error('å›¾ä¹¦æ£€ç´¢ API å“åº”å¼‚å¸¸ï¼šç¼ºå°‘ context_plain_text');
    }

    // è§£æç»“æ„åŒ–æ•°æ®
    const structuredData = await parseRetrievalResponse(response, endpoint, payload);

    return {
        contextPlainText,
        metadata,
        structuredData
    };
}

// ä¿®æ”¹textSearchå‡½æ•°
export async function textSearch(payload: TextSearchPayload): Promise<EnhancedRetrievalResult> {
    const enriched = ensureTemplate(ensureFormat(payload));
    return postBookApi('/api/books/text-search', enriched);
}

// ä¿®æ”¹multiQueryå‡½æ•°
export async function multiQuery(payload: MultiQueryPayload): Promise<EnhancedRetrievalResult> {
    const enriched = ensureTemplate(ensureFormat(payload));
    return postBookApi('/api/books/multi-query', enriched);
}
```

### 2.2 ä¿®æ”¹ `src/core/aibot/researchWorkflow.ts`

ä¿®æ”¹buildChatWorkflowContextå‡½æ•°ï¼š

```typescript
// ä¿®æ”¹å‡½æ•°ç­¾åï¼Œè¿”å›ç±»å‹åŒ…å«retrievalResultData
export async function buildChatWorkflowContext(
    input: ChatWorkflowInput
): Promise<ChatWorkflowContext & { retrievalResultData?: RetrievalResultData }> {
    const userInput = extractLatestUserMessage(input.messages);

    logger.info('buildChatWorkflowContext å¼€å§‹', {
        mode: input.mode,
        userInput,
        messagesCount: input.messages.length,
        hasDraftMarkdown: !!input.draftMarkdown,
        hasDeepMetadata: !!input.deepMetadata,
        deepMetadataDraftMarkdown: input.deepMetadata?.draftMarkdown?.slice(0, 100) || null
    });

    if (!userInput) {
        throw new Error('ç¼ºå°‘ç”¨æˆ·è¾“å…¥å†…å®¹ï¼Œæ— æ³•å¯åŠ¨ AIBot å·¥ä½œæµ');
    }

    const draftMarkdown = input.draftMarkdown ?? input.deepMetadata?.draftMarkdown ?? '';

    logger.info('buildChatWorkflowContext è‰ç¨¿æ£€æŸ¥', {
        inputDraftMarkdown: input.draftMarkdown?.slice(0, 100) || null,
        deepMetadataDraftMarkdown: input.deepMetadata?.draftMarkdown?.slice(0, 100) || null,
        finalDraftMarkdown: draftMarkdown?.slice(0, 100) || null,
        mode: input.mode
    });

    if (input.mode === AIBOT_MODES.DEEP && !draftMarkdown.trim()) {
        throw new Error('æ·±åº¦æ£€ç´¢ç¼ºå°‘è‰ç¨¿å†…å®¹');
    }

    // ä½¿ç”¨ä¿®æ”¹åçš„æ£€ç´¢å‡½æ•°ï¼Œç°åœ¨è¿”å›EnhancedRetrievalResult
    const retrieval =
        input.mode === AIBOT_MODES.TEXT
            ? await textSearch({
                query: userInput,
                top_k: DEFAULT_TOP_K
            })
            : await multiQuery({
                markdown_text: draftMarkdown,
                per_query_top_k: DEFAULT_MULTI_QUERY_TOP_K,
                final_top_k: DEFAULT_TOP_K
            });

    if (!retrieval.contextPlainText) {
        logger.error('æ£€ç´¢ç»“æœä¸ºç©º', { mode: input.mode });
        throw new Error('å›¾ä¹¦æ£€ç´¢è¿”å›ç©ºç»“æœ');
    }

    // æ ¹æ®æ¨¡å¼é€‰æ‹©ä¸åŒçš„æç¤ºè¯
    const promptFile = input.mode === AIBOT_MODES.TEXT
        ? AIBOT_PROMPT_FILES.SIMPLE_SEARCH
        : AIBOT_PROMPT_FILES.RECOMMENDATION;
    
    const basePrompt = await loadPrompt(promptFile);
    const composedSystemPrompt = buildSystemPrompt(
        basePrompt,
        retrieval.contextPlainText,
        userInput,
        draftMarkdown
    );

    const metadata = (retrieval.metadata ?? {}) as Record<string, unknown>;
    const llmHint = (metadata.llm_hint ?? metadata.llmHint) as LLMHintMetadata | undefined;
    const llmConfig = resolveLLMConfig(llmHint);

    return {
        mode: input.mode,
        systemPrompt: composedSystemPrompt,
        contextPlainText: retrieval.contextPlainText,
        metadata,
        llmConfig,
        retrievalResultData: retrieval.structuredData // æ–°å¢å­—æ®µ
    };
}
```

### 2.3 ä¿®æ”¹ `app/api/local-aibot/chat/route.ts`

ä¿®æ”¹POSTå‡½æ•°ä»¥è¿”å›æ£€ç´¢ç»“æœï¼š

```typescript
// åœ¨streamHeaderså‡½æ•°åæ·»åŠ æ–°çš„å“åº”å¤´æ„å»ºå‡½æ•°
const streamHeadersWithRetrieval = (
    classification: IntentClassificationResult,
    mode: AIBotMode,
    retrievalResultData?: RetrievalResultData
): Record<string, string> => ({
    'X-AIBot-Mode': mode,
    'X-AIBot-Intent': classification.intent,
    'X-AIBot-Intent-Confidence': classification.confidence.toFixed(2),
    ...(retrievalResultData && {
        'X-Retrieval-Result': JSON.stringify(retrievalResultData)
    })
});

// ä¿®æ”¹POSTå‡½æ•°ä¸­çš„è¿”å›éƒ¨åˆ†
const workflowContext = await buildChatWorkflowContext({
    mode: resolvedMode,
    messages: chatMessages,
    draftMarkdown: typeof payload?.draft_markdown === 'string' ? payload.draft_markdown : undefined,
    deepMetadata: payload?.deep_metadata as any
});

logger.info('å·¥ä½œæµä¸Šä¸‹æ–‡æ„å»ºå®Œæˆ', {
    hasSystemPrompt: !!workflowContext.systemPrompt,
    llmConfig: workflowContext.llmConfig,
    hasRetrievalResultData: !!workflowContext.retrievalResultData,
    booksCount: workflowContext.retrievalResultData?.books.length || 0
});

const result = streamText({
    model: createModel(workflowContext.llmConfig),
    system: workflowContext.systemPrompt,
    messages: chatMessages as any
});

return result.toTextStreamResponse({
    headers: streamHeadersWithRetrieval(classification, workflowContext.mode, workflowContext.retrievalResultData)
});
```

## 3. å‰ç«¯çŠ¶æ€ç®¡ç†ä¿®æ”¹

### 3.1 ä¿®æ”¹ `store/aibot/useAIBotStore.ts`

æ‰©å±•çŠ¶æ€å’Œæ“ä½œï¼š

```typescript
// åœ¨importéƒ¨åˆ†æ·»åŠ 
import type { RetrievalResultData } from '@/src/core/aibot/types';

// åœ¨AIBotStateæ¥å£ä¸­æ·»åŠ 
interface AIBotState {
    // ç°æœ‰å­—æ®µ...
    retrievalResults: Map<string, RetrievalResultData>; // æ¶ˆæ¯ID -> æ£€ç´¢ç»“æœ
    setRetrievalResult: (messageId: string, result: RetrievalResultData) => void;
    clearRetrievalResults: () => void;
}

// åœ¨initialStateä¸­æ·»åŠ 
const initialState: Omit<AIBotState, 'toggleOverlay' | 'setDeepMode' | 'setMessages' | 'setPendingDraft' | 'setStreaming' | 'setDraftLoading' | 'setError' | 'reset' | 'appendMessage' | 'updateLastAssistantMessage' | 'setRetrievalResult' | 'clearRetrievalResults'> = {
    // ç°æœ‰å­—æ®µ...
    retrievalResults: new Map(),
};

// åœ¨storeå®ç°ä¸­æ·»åŠ 
export const useAIBotStore = create<AIBotState>((set) => ({
    ...initialState,
    // ç°æœ‰æ–¹æ³•...
    setRetrievalResult: (messageId, result) =>
        set((state) => {
            const newRetrievalResults = new Map(state.retrievalResults);
            newRetrievalResults.set(messageId, result);
            return { retrievalResults: newRetrievalResults };
        }),
    clearRetrievalResults: () => set({ retrievalResults: new Map() }),
    reset: () => set({ ...initialState, retrievalResults: new Map() })
}));
```

## 4. å‰ç«¯ç»„ä»¶ä¿®æ”¹

### 4.1 ä¿®æ”¹ `components/aibot/AIBotOverlay.tsx`

ä¿®æ”¹streamAssistantå‡½æ•°ä»¥å¤„ç†æ£€ç´¢ç»“æœï¼š

```typescript
// åœ¨streamAssistantå‡½æ•°ä¸­ä¿®æ”¹fetchè°ƒç”¨
try {
    const response = await fetch('/api/local-aibot/chat', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
    });

    if (!response.ok || !response.body) {
        const fallback = await response.text();
        throw new Error(fallback || 'å“åº”å¼‚å¸¸');
    }

    // è§£ææ£€ç´¢ç»“æœ
    const retrievalResultHeader = response.headers.get('X-Retrieval-Result');
    let retrievalResultData: RetrievalResultData | undefined;
    
    if (retrievalResultHeader) {
        try {
            retrievalResultData = JSON.parse(retrievalResultHeader);
        } catch (error) {
            console.error('è§£ææ£€ç´¢ç»“æœå¤±è´¥:', error);
        }
    }

    const assistantMessage: UIMessage = {
        id: crypto.randomUUID(),
        role: 'assistant',
        content: ''
    } as any;
    
    appendMessage(assistantMessage);
    
    // å¦‚æœæœ‰æ£€ç´¢ç»“æœï¼Œå­˜å‚¨åˆ°çŠ¶æ€ä¸­
    if (retrievalResultData) {
        setRetrievalResult(assistantMessage.id, retrievalResultData);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        updateLastAssistantMessage(buffer);
    }
} catch (err) {
    setError(err instanceof Error ? err.message : 'è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
} finally {
    setStreaming(false);
}
```

### 4.2 ä¿®æ”¹ `components/aibot/MessageStream.tsx`

ä¿®æ”¹æ¶ˆæ¯æ¸²æŸ“é€»è¾‘ï¼š

```typescript
// åœ¨importéƒ¨åˆ†æ·»åŠ 
import RetrievalResultDisplay from './RetrievalResultDisplay';
import { useAIBotStore } from '@/store/aibot/useAIBotStore';

// ä¿®æ”¹MessageStreamç»„ä»¶
export default function MessageStream({ messages, isStreaming }: MessageStreamProps) {
    const { retrievalResults } = useAIBotStore(); // è·å–æ£€ç´¢ç»“æœçŠ¶æ€

    // è°ƒè¯•æ—¥å¿—ä¿æŒä¸å˜...
    useEffect(() => {
        if (process.env.NODE_ENV === 'development') {
            console.log('[MessageStream DEBUG]', {
                æ¶ˆæ¯æ•°é‡: messages.length,
                æµå¼çŠ¶æ€: isStreaming,
                æ€»å†…å®¹é•¿åº¦: messages.reduce((sum, msg) => sum + msg.content.length, 0),
                æ—¶é—´æˆ³: new Date().toISOString(),
                æ£€ç´¢ç»“æœæ•°é‡: retrievalResults.size
            });
        }
    }, [messages, isStreaming, retrievalResults]);

    return (
        <div
            className="flex-1 overflow-y-auto pr-2 space-y-4 aibot-scroll"
            style={{
                maxHeight: '100%',
                minHeight: '0'
            }}
        >
            <AnimatePresence initial={false}>
                {messages.map((message) => (
                    <motion.div
                        key={message.id}
                        initial={{ opacity: 0, y: 10 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10 }}
                        className={message.role === 'user' ? 'text-right' : 'text-left'}
                    >
                        {message.role === 'assistant' && (
                            <>
                                {/* æ£€ç´¢ç»“æœæ˜¾ç¤º */}
                                {retrievalResults.get(message.id) && (
                                    <RetrievalResultDisplay 
                                        retrievalResult={retrievalResults.get(message.id)!}
                                    />
                                )}
                            </>
                        )}
                        
                        <div
                            className={`inline-block rounded-2xl px-4 py-3 text-sm leading-relaxed whitespace-pre-wrap font-info-content ${
                                message.role === 'user'
                                    ? 'bg-[#2F2F2F] text-[#E8E6DC]'
                                    : 'bg-[#1B1B1B] border border-[#343434] text-[#E8E6DC]'
                            }`}
                        >
                            {message.content}
                        </div>
                    </motion.div>
                ))}
            </AnimatePresence>
            {isStreaming && (
                <div className="text-left text-xs text-[#A2A09A] animate-pulse">
                    æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...
                </div>
            )}
        </div>
    );
}
```

## 5. æ–°å¢ç»„ä»¶æ–‡ä»¶

### 5.1 åˆ›å»º `components/aibot/RetrievalResultDisplay.tsx`

```typescript
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import type { RetrievalResultData } from '@/src/core/aibot/types';
import BookItem from './BookItem';

export default function RetrievalResultDisplay({ 
    retrievalResult 
}: { 
    retrievalResult: RetrievalResultData 
}) {
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [showAll, setShowAll] = useState(false);

    const displayBooks = showAll 
        ? retrievalResult.books 
        : retrievalResult.books.slice(0, 3);

    return (
        <div className="retrieval-result-container mb-3">
            {/* æŠ˜å å¤´éƒ¨ */}
            <motion.div 
                className="retrieval-header flex items-center justify-between p-3 cursor-pointer bg-[rgba(201,160,99,0.1)] rounded-t-xl border border-[#343434] border-b-0"
                onClick={() => setIsCollapsed(!isCollapsed)}
                whileHover={{ backgroundColor: 'rgba(201, 160, 99, 0.2)' }}
                transition={{ duration: 0.2 }}
            >
                <div className="flex items-center gap-3">
                    <span className="text-[#C9A063] text-sm font-info-content font-medium">
                        {retrievalResult.searchType === 'text-search' ? 'ğŸ“š ç®€å•æ£€ç´¢' : 'ğŸ” æ·±åº¦æ£€ç´¢'}
                    </span>
                    <span className="text-[#E8E6DC] text-sm">
                        æ‰¾åˆ° {retrievalResult.totalCount} æœ¬ç›¸å…³å›¾ä¹¦
                    </span>
                    <span className="text-[#6F6D68] text-xs">
                        æ£€ç´¢è¯: "{retrievalResult.searchQuery.slice(0, 20)}{retrievalResult.searchQuery.length > 20 ? '...' : ''}"
                    </span>
                </div>
                <motion.div
                    animate={{ rotate: isCollapsed ? 180 : 0 }}
                    transition={{ duration: 0.2 }}
                    className="text-[#A2A09A]"
                >
                    â–¼
                </motion.div>
            </motion.div>

            {/* å¯æŠ˜å å†…å®¹ */}
            <AnimatePresence>
                {!isCollapsed && (
                    <motion.div
                        initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }}
                        exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.3 }}
                        className="overflow-hidden"
                    >
                        <div className="book-list p-4 border border-[#343434] border-t-0 rounded-b-xl bg-[rgba(26,26,26,0.8)] max-h-96 overflow-y-auto">
                            {displayBooks.map((book, index) => (
                                <BookItem 
                                    key={`${book.id}-${index}`} 
                                    book={book} 
                                    isCompact={true}
                                />
                            ))}
                            
                            {/* æ˜¾ç¤ºæ›´å¤šæŒ‰é’® */}
                            {retrievalResult.books.length > 3 && (
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        setShowAll(!showAll);
                                    }}
                                    className="w-full py-2 mt-3 text-center text-[#C9A063] text-sm hover:bg-[#1B1B1B] rounded-lg transition-colors border border-[#343434]"
                                >
                                    {showAll ? 'â–² æ”¶èµ·' : `â–¼ æ˜¾ç¤ºå…¨éƒ¨ ${retrievalResult.books.length} æœ¬`}
                                </button>
                            )}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}
```

### 5.2 åˆ›å»º `components/aibot/BookItem.tsx`

```typescript
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import type { BookInfo } from '@/src/core/aibot/types';

export default function BookItem({ 
    book, 
    isCompact = false 
}: { 
    book: BookInfo; 
    isCompact?: boolean;
}) {
    const [isExpanded, setIsExpanded] = useState(false);

    return (
        <motion.div
            className={`book-item ${isExpanded ? 'expanded' : ''} flex gap-3 p-3 rounded-lg bg-[rgba(27,27,27,0.6)] mb-2 cursor-pointer transition-all duration-200 hover:bg-[rgba(201,160,99,0.15)] hover:translate-x-1`}
            whileHover={{ scale: 1.01 }}
            onClick={() => !isCompact && setIsExpanded(!isExpanded)}
        >
            {/* å›¾ä¹¦å°é¢ */}
            {book.coverUrl && (
                <img 
                    src={book.coverUrl} 
                    alt={book.title}
                    className="w-12 h-16 object-cover rounded flex-shrink-0"
                    onError={(e) => {
                        // å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶éšè—
                        (e.target as HTMLImageElement).style.display = 'none';
                    }}
                />
            )}
            
            {/* åŸºæœ¬ä¿¡æ¯ */}
            <div className="flex-1 min-w-0">
                <h3 className="text-[#E8E6DC] font-medium text-sm truncate mb-1">
                    {book.title}
                </h3>
                {book.subtitle && !isCompact && (
                    <p className="text-[#A2A09A] text-xs truncate mb-1">
                        {book.subtitle}
                    </p>
                )}
                <p className="text-[#A2A09A] text-sm mb-1">
                    {book.author}
                </p>
                
                <div className="flex items-center gap-3 flex-wrap">
                    {book.rating && (
                        <div className="flex items-center gap-1">
                            <span className="text-[#C9A063] text-xs">â˜…</span>
                            <span className="text-[#E8E6DC] text-xs">{book.rating}</span>
                        </div>
                    )}
                    {book.callNumber && (
                        <div className="flex items-center gap-1">
                            <span className="text-[#6F6D68] text-xs">ç´¢ä¹¦å·:</span>
                            <span className="text-[#C9A063] text-xs font-medium">{book.callNumber}</span>
                        </div>
                    )}
                    {book.publishYear && (
                        <span className="text-[#6F6D68] text-xs">{book.publishYear}å¹´</span>
                    )}
                </div>

                {/* äº®ç‚¹ä¿¡æ¯ */}
                {book.highlights && book.highlights.length > 0 && (
                    <div className="mt-2">
                        <p className="text-[#A2A09A] text-xs line-clamp-2">
                            {book.highlights.join('; ')}
                        </p>
                    </div>
                )}
            </div>

            {/* å±•å¼€çš„è¯¦ç»†ä¿¡æ¯ */}
            <AnimatePresence>
                {isExpanded && !isCompact && (
                    <motion.div
                        initial={{ opacity: 0, height: 0 }}
                        animate={{ opacity: 1, height: 'auto' }}
                        exit={{ opacity: 0, height: 0 }}
                        transition={{ duration: 0.3 }}
                        className="col-span-full mt-4 p-4 bg-[#1B1B1B] rounded-lg border border-[#343434]"
                    >
                        {book.description && (
                            <div className="mb-3">
                                <h4 className="text-[#C9A063] font-medium mb-2 text-sm">å†…å®¹ç®€ä»‹</h4>
                                <p className="text-[#A2A09A] text-sm leading-relaxed">{book.description}</p>
                            </div>
                        )}
                        
                        {book.authorIntro && (
                            <div className="mb-3">
                                <h4 className="text-[#C9A063] font-medium mb-2 text-sm">ä½œè€…ç®€ä»‹</h4>
                                <p className="text-[#A2A09A] text-sm leading-relaxed">{book.authorIntro}</p>
                            </div>
                        )}
                        
                        <div className="grid grid-cols-2 gap-4 text-sm">
                            {book.publisher && (
                                <div>
                                    <span className="text-[#6F6D68]">å‡ºç‰ˆç¤¾ï¼š</span>
                                    <span className="text-[#E8E6DC]">{book.publisher}</span>
                                </div>
                            )}
                            {book.pageCount && (
                                <div>
                                    <span className="text-[#6F6D68]">é¡µæ•°ï¼š</span>
                                    <span className="text-[#E8E6DC]">{book.pageCount}</span>
                                </div>
                            )}
                            {book.isbn && (
                                <div>
                                    <span className="text-[#6F6D68]">ISBNï¼š</span>
                                    <span className="text-[#E8E6DC]">{book.isbn}</span>
                                </div>
                            )}
                            {book.tags && book.tags.length > 0 && (
                                <div className="col-span-2">
                                    <span className="text-[#6F6D68]">æ ‡ç­¾ï¼š</span>
                                    <span className="text-[#E8E6DC]">{book.tags.join(', ')}</span>
                                </div>
                            )}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </motion.div>
    );
}
```

## 6. CSSæ ·å¼æ·»åŠ 

### 6.1 åœ¨ `app/globals.css` ä¸­æ·»åŠ æ ·å¼

```css
/* æ£€ç´¢ç»“æœå®¹å™¨æ ·å¼ */
.retrieval-result-container {
    background: rgba(26, 26, 26, 0.8);
    border-radius: 12px;
    backdrop-filter: blur(10px);
    font-family: var(--font-info-content);
}

/* æŠ˜å å¤´éƒ¨æ ·å¼ */
.retrieval-header {
    user-select: none;
}

/* å›¾ä¹¦åˆ—è¡¨æ»šåŠ¨æ¡æ ·å¼ */
.book-list::-webkit-scrollbar {
    width: 6px;
}

.book-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 3px;
}

.book-list::-webkit-scrollbar-thumb {
    background: rgba(201, 160, 99, 0.3);
    border-radius: 3px;
}

.book-list::-webkit-scrollbar-thumb:hover {
    background: rgba(201, 160, 99, 0.5);
}

/* å›¾ä¹¦å¡ç‰‡æ ·å¼ */
.book-item {
    border: 1px solid rgba(52, 52, 52, 0.3);
}

.book-item:hover {
    border-color: rgba(201, 160, 99, 0.3);
}

/* æ–‡æœ¬æˆªæ–­æ ·å¼ */
.line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* å“åº”å¼è°ƒæ•´ */
@media (max-width: 768px) {
    .retrieval-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
    }
    
    .book-item {
        flex-direction: column;
        gap: 8px;
    }
    
    .book-item img {
        align-self: center;
    }
}
```

## 7. å®æ–½æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šç±»å‹å®šä¹‰å’Œåç«¯ä¿®æ”¹
1. ä¿®æ”¹ `src/core/aibot/types.ts` æ·»åŠ æ–°ç±»å‹
2. ä¿®æ”¹ `src/core/aibot/retrievalService.ts` å®ç°ç»“æ„åŒ–æ•°æ®è§£æ
3. ä¿®æ”¹ `src/core/aibot/researchWorkflow.ts` è¿”å›æ£€ç´¢ç»“æœæ•°æ®
4. ä¿®æ”¹ `app/api/local-aibot/chat/route.ts` åœ¨å“åº”å¤´ä¸­è¿”å›æ£€ç´¢ç»“æœ

### ç¬¬äºŒæ­¥ï¼šå‰ç«¯çŠ¶æ€ç®¡ç†
1. ä¿®æ”¹ `store/aibot/useAIBotStore.ts` æ·»åŠ æ£€ç´¢ç»“æœçŠ¶æ€ç®¡ç†
2. ä¿®æ”¹ `components/aibot/AIBotOverlay.tsx` å¤„ç†æ£€ç´¢ç»“æœå“åº”

### ç¬¬ä¸‰æ­¥ï¼šUIç»„ä»¶å¼€å‘
1. åˆ›å»º `components/aibot/BookItem.tsx` å›¾ä¹¦å¡ç‰‡ç»„ä»¶
2. åˆ›å»º `components/aibot/RetrievalResultDisplay.tsx` æ£€ç´¢ç»“æœå±•ç¤ºç»„ä»¶
3. ä¿®æ”¹ `components/aibot/MessageStream.tsx` é›†æˆæ£€ç´¢ç»“æœæ˜¾ç¤º

### ç¬¬å››æ­¥ï¼šæ ·å¼å’Œä¼˜åŒ–
1. åœ¨ `app/globals.css` ä¸­æ·»åŠ æ ·å¼
2. æµ‹è¯•åŠŸèƒ½å®Œæ•´æ€§
3. ä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ

## 8. æµ‹è¯•è¦ç‚¹

### 8.1 åŠŸèƒ½æµ‹è¯•
- ç®€å•æ£€ç´¢ç»“æœæ˜¾ç¤º
- æ·±åº¦æ£€ç´¢ç»“æœæ˜¾ç¤º
- æŠ˜å /å±•å¼€åŠŸèƒ½
- å›¾ä¹¦å¡ç‰‡äº¤äº’
- å“åº”å¼å¸ƒå±€

### 8.2 æ€§èƒ½æµ‹è¯•
- å¤§é‡å›¾ä¹¦æ•°æ®çš„æ¸²æŸ“æ€§èƒ½
- æ»šåŠ¨æ€§èƒ½
- å†…å­˜ä½¿ç”¨æƒ…å†µ

### 8.3 å…¼å®¹æ€§æµ‹è¯•
- ä¸ç°æœ‰èŠå¤©åŠŸèƒ½çš„å…¼å®¹æ€§
- ä¸åŒæµè§ˆå™¨çš„å…¼å®¹æ€§
- ç§»åŠ¨ç«¯é€‚é…

## 9. æ•…éšœæ’é™¤

### 9.1 å¸¸è§é—®é¢˜
1. **æ£€ç´¢ç»“æœä¸æ˜¾ç¤º**ï¼šæ£€æŸ¥å“åº”å¤´è§£æé€»è¾‘
2. **æ ·å¼å¼‚å¸¸**ï¼šç¡®è®¤CSSç±»åå’Œé€‰æ‹©å™¨æ­£ç¡®
3. **æ€§èƒ½é—®é¢˜**ï¼šè€ƒè™‘ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨æˆ–åˆ†é¡µ

### 9.2 è°ƒè¯•æŠ€å·§
1. ä½¿ç”¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·æ£€æŸ¥ç½‘ç»œè¯·æ±‚
2. æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—ä¸­çš„é”™è¯¯ä¿¡æ¯
3. ä½¿ç”¨React DevToolsæ£€æŸ¥ç»„ä»¶çŠ¶æ€

## 10. åç»­ä¼˜åŒ–å»ºè®®

1. **ç¼“å­˜æœºåˆ¶**ï¼šå¯¹æ£€ç´¢ç»“æœè¿›è¡Œç¼“å­˜ï¼Œé¿å…é‡å¤è¯·æ±‚
2. **åˆ†é¡µåŠ è½½**ï¼šå¯¹äºå¤§é‡å›¾ä¹¦ç»“æœï¼Œå®ç°åˆ†é¡µæˆ–è™šæ‹Ÿæ»šåŠ¨
3. **æœç´¢è¿‡æ»¤**ï¼šåœ¨æ£€ç´¢ç»“æœä¸­æ·»åŠ æœç´¢å’Œè¿‡æ»¤åŠŸèƒ½
4. **å¯¼å‡ºåŠŸèƒ½**ï¼šæ”¯æŒå°†æ£€ç´¢ç»“æœå¯¼å‡ºä¸ºä¸åŒæ ¼å¼
5. **ä¸ªæ€§åŒ–æ¨è**ï¼šåŸºäºç”¨æˆ·å†å²è¡Œä¸ºä¼˜åŒ–æ£€ç´¢ç»“æœå±•ç¤º